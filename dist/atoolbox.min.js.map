{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/_index.js","src/array.js","src/hash.js","src/object.js","src/random.js","src/string.js","src/task.js","src/time.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"atoolbox.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","window.tools={\narray: require('./array'),\nhash: require('./hash'),\nobject: require('./object'),\nrandom: require('./random'),\nstring: require('./string'),\ntask: require('./task'),\ntime: require('./time')\n}","/**\n * array utils, inspired to goog.array\n * @namespace tools.array\n */\nconst array = {\n  /**\n   * @method tools.array.remove\n   * remove an element from array, only once\n   * @todo item=object, date, regexp ...\n   * @todo remove all item, not only first\n   * @param {Array<*>} array\n   * @param {*} item\n   * @test.case [1,2,3], 2 > &[1,3]\n   * @test.case [1,2,3], 3 > &[1,2]\n   * @test.case ['js','ruby','python'], 1 > &['js','python']\n   */\n  remove: function (array, item) {\n    const _index = array.indexOf(item)\n    if (_index !== -1) {\n      array.splice(_index, 1)\n    }\n  },\n  /**\n   * remove an element from array at position\n   * @param {Array<*>} array\n   * @param {number} index\n   * @test.case [1,2,3], 0 > &[2,3]\n   * @test.case [1,2,3], 1 > &[1,3]\n   * @test.case [1,2,3], -1 > &[1,2]\n   * @test.case [1,2,3], 4 > &[1,2,3]\n   */\n  removeAt: function (array, index) {\n    return Array.prototype.splice.call(array, index, 1).length === 1\n  },\n  /**\n   * get last element of array or undefined\n   * @param {Array<*>} array\n   * @return {*} last element of the array or undefined\n   * @test.case [1,2,3] > 3\n   * @test.case [null, 0, -1] > -1\n   * @test.case [null] > null\n   * @test.case [0] > 0\n   * @test.case [] > undefined\n   * @test.case [1, undefined] > undefined\n   */\n  last: function (array) {\n    return array[array.length - 1]\n  },\n  /**\n   * get nth element of array\n   * @param {Array<*>} array\n   * @return {*} nth element of array; if negative, start from end: -1 = last element; undefined if missing\n   * @test.case [1,2,3], 0 > 1\n   * @test.case [0,1,null,3], 0 > 0\n   * @test.case [0,1,null,false], -1 > false\n   * @test.case [0,1,null,false], -2 > null\n   * @test.case [0,1,'0',false], -2 > '0'\n   * @test.case [undefined,'0',false], 0 > undefined\n   * @test.case [], 2 > undefined\n   */\n  at: function (array, p) {\n    if (p < 0) {\n      p = array.length + p\n    }\n    return array[p]\n  },\n  /**\n   * get first element of array or undefined\n   * @param {Array<*>} array\n   * @return {*} first element of the array or undefined\n   * @test.case [1,2,3] > 1\n   * @test.case [0,1,null,3] > 0\n   * @test.case [1,null,false] > 1\n   * @test.case [null,false] > null\n   * @test.case [undefined,'0',false] > undefined\n   * @test.case [] > undefined\n   */\n  first: function (array) {\n    return array[0]\n  },\n  /**\n   * check if array contains an element\n   * @param {Array<*>} array\n   * @param {*} item\n   * @return {boolean}\n   */\n  contains: function (array, item) {\n    return array.indexOf(item) !== -1\n  },\n  /**\n   * insert an item into array at index position\n   * @param {Array<*>} array\n   * @param {number} index\n   * @param {*} item\n   * @test.case ['john', 'alice', 'bob'], 0, 'mary' > &['mary', 'john', 'alice', 'bob']\n   * @test.case ['john', 'alice', 'bob'], 1, 'mary' > &['john', 'mary', 'alice', 'bob']\n   * @test.case ['john', 'alice', 'bob'], -1, 'mary' > &['john', 'alice', 'bob', 'mary']\n   * @test.case ['john', 'alice', 'bob'], -2, 'mary' > &['john', 'alice', 'mary', 'bob']\n   */\n  insert: function (array, index, item) {\n    if (index > array.length) {\n      index = array.length\n    }\n\n    if (array[index]) {\n      array.splice(index, 0, item)\n    } else {\n      array[index] = item\n    }\n  },\n\n  /**\n   * concat arrays\n   * @param {...Array<*>} arrays to chain\n   * @return {Array<*>} chained arrays\n   * @test.case [0,1,2],[3,4,5] > [0,1,2,3,4,5]\n   * @test.case [0, 1, 2, 3], ['a', 'b', 'c'], [{a: 2}] > [0, 1, 2, 3, 'a', 'b', 'c', {a: 2}]\n   */\n  concat: function (args) {\n    return Array.prototype.concat.apply(Array.prototype, arguments)\n  },\n  /**\n   * empty array - need to keep references\n   * @test.case [0,1,2] > &[]\n   * @test.case [] > &[]\n   */\n  empty: function (array) {\n    while (array[0]) {\n      array.pop()\n    }\n  },\n  /**\n   * push item into array, optionally check if already exists\n   */\n  add: function (array, item, unique) {\n    if (unique && array.contains(array, item)) {\n      return\n    }\n    array.push(item)\n  }\n\n}\n\nmodule.exports = array\n","//const crypto = require('crypto')\n\n/**\n * @namespace tools.hash\n */\nconst hash = {\n  /**\n   * Generate hash using sha256 in hex format\n   * @method tools.hash.sha256\n   * @param {string} data any string\n   * @return {string} sha256 in hex format\n   *\n   * @test\n   * 'usk6fgbuygbu6' > 'ee42f619919727584b66fe25248ed4bba8e87dcfb3e62a90143ea17ba48df58e'\n   * @test\n   * 'lorem ipsum %1283770tv8gv 6c6fgw ucthv iy'\n   * > '18d18c26ed98c0e88d9121132be48f42596e899ac50f15f854c9d0a82b9f2cb5'\n   */\n  sha256: function (data) {\n    return crypto.createHash('sha256')\n      .update(data)\n      .digest('hex')\n  }\n}\n\nmodule.exports = hash\n","/**\n * @namespace tools.object\n */\nconst object = {\n  /**\n   * merge obj2 into obj1\n   * @param {Object} obj1\n   * @param {Object} obj2\n   * @test.case {a: 1, b: 'ciao'}, {a: 4, c: { d: 8, e: 9}} > &{ a: 4, b: 'ciao', c: { d: 8, e: 9 } }\n   */\n  merge: function (obj1, obj2) {\n    if (!obj1) {\n      obj1 = obj2 || {}\n      return\n    }\n    if (!obj2) {\n      return obj1\n    }\n\n    for (var i in obj2) {\n      if (typeof obj2[i] === 'object') {\n        if (obj2[i] instanceof Array) {\n          obj1[i] = object.clone(obj2[i])\n          continue\n        }\n        if (!obj1[i] || typeof obj1[i] !== 'object') {\n          obj1[i] = {}\n        }\n        object.merge(obj1[i], obj2[i])\n      } else {\n        obj1[i] = obj2[i]\n      }\n    }\n  },\n  /**\n   * Clone an array or an object in input\n   * @function\n   * @param {Object|Array} obj The array or the object to clone\n   * @return {Object|Array}\n   */\n  clone: function (obj) {\n    if (obj === null || obj === undefined) {\n      return obj\n    }\n    var _type = (obj instanceof Array) ? 'array' : typeof obj\n    if (_type === 'object' || _type === 'array') {\n      if (obj instanceof Date) {\n        return new Date(obj.getTime())\n      } else if (typeof window !== 'undefined') {\n        return obj\n      } else {\n        if (obj.clone) {\n          return obj.clone()\n        }\n          /**\n           * @type {Array|Object}\n           */\n        var _clone = _type === 'array' ? [] : {}\n        for (var key in obj) {\n          _clone[key] = object.clone(obj[key])\n        }\n        return _clone\n      }\n    }\n    return obj\n  },\n  /**\n   * @see http://google.github.io/closure-library/api/source/closure/goog/object/object.js.src.html#l225\n   * @param {Object} obj\n   * @return {Array}\n   */\n  getKeys: function (obj) {\n    if (Object.keys) {\n      return Object.keys(obj)\n    }\n    var _keys = []\n    for (var key in obj) {\n      _keys.push(key)\n    }\n    return _keys\n  },\n\n  /**\n   * @todo check if both are objects\n   */\n  inherits: function (destination, source) {\n      //      util.inherits(destination, source)\n    Object.getOwnPropertyNames(source).forEach((property) => {\n      destination[property] = source[property]\n    })\n  },\n\n  /**\n   * empty object - need to keep references\n   * @test.case {a:0,b:1,c:2,d:[],e:{f:-1}} > &{}\n   * @test.case {} > &{}\n   */\n  empty: function (obj) {\n    for (const i in obj) {\n      delete obj[i]\n    }\n  },\n\n  /**\n   * flat keys in object\n   * @param {object} obj\n   * @returns {object}\n   * @test.case { a: { a1: 1, a2: 2 }, b: 3 } > { 'a.a1': 1, 'a.a2': 2, 'b': 3 }\n   */\n  flat: function (obj) {\n    const _flat = {}\n\n    const _f = function (obj, base) {\n      for (const key in obj) {\n        try {\n          // eslint-disable-next-line eqeqeq\n          if (obj[key].constructor == Object) {\n            _f(obj[key], base + key + '.')\n          } else {\n            _flat[base + key] = obj[key]\n          }\n        } catch (e) {\n          _flat[base + key] = obj[key]\n        }\n      }\n    }\n    _f(obj, '')\n\n    return _flat\n  },\n  /**\n   * restore flat object\n   * @param {object} obj\n   * @returns {object}\n   * @test.case { 'a.a1': 1, 'a.a2': 2, 'b': 3 } > { a: { a1: 1, a2: 2 }, b: 3 }\n   */\n  raise: function (obj) {\n    const _raise = {}\n\n    const _f = function (flat, raise) {\n      for (const path in flat) {\n        const _keys = path.split('.')\n        let _cursor = raise\n        _keys.forEach((key, i) => {\n          if (i < _keys.length - 1) {\n            if (!_cursor[key]) {\n              _cursor[key] = {}\n            }\n            _cursor = _cursor[key]\n          } else {\n            _cursor[key] = flat[path]\n          }\n        })\n      }\n    }\n    _f(obj, _raise)\n\n    return _raise\n  },\n  /**\n   * get value in object using a flat key\n   * @todo check params\n   * @param {object} obj\n   * @param {string} fkey\n   * @returns {object}\n   * @test.case { a: { b: {c: 1} } }, 'a.b.c' > 1\n   */\n  getByFlatKey: function (obj, fkey) {\n    let _path = fkey.split('.')\n    let _walk = obj\n    for (let i = 0; i < _path.length; i++) {\n      if (!_walk[_path[i]]) {\n        return undefined\n      }\n      _walk = _walk[_path[i]]\n    }\n    return _walk\n  },\n\n  /**\n   * set value in object using a flat key\n   * @todo check params\n   * @param {object} obj\n   * @param {string} fkey\n   * @param {*} val\n   * @test.case\n   * {}, 'a.b.c', 1 > &{ a: { b: {c: 1} } }\n   */\n  setByFlatKey: function (obj, fkey, val) {\n    let _path = fkey.split('.')\n    let _walk = obj\n    for (let i = 0; i < _path.length; i++) {\n      if (!_walk[_path[i]]) {\n          // if it's the last step, add key as undefined\n        if (i === _path.length - 1) {\n          _walk[_path[i]] = undefined\n          return\n        }\n        _walk[_path[i]] = {}\n      }\n      _walk = _walk[_path[i]]\n    }\n    _walk = val\n  }\n}\n\nmodule.exports = object\n","const hash = require('./hash')\n\n/**\n * @namespace tools.random\n */\nconst random = {\n  /**\n   * get random int from 0 to max\n   * @method tools.random.rnd\n   * @param {number} max\n   * @return {number}\n   */\n  rnd: function (max) {\n    if (!max) {\n      return 0\n    }\n    return Math.floor(max * Math.random())\n  },\n  /**\n   * get random int from min to max\n   * @method tools.random.number\n   * @param {number} min\n   * @param {number} max\n   * @return {number}\n   */\n  number: function (min, max) {\n    if (!max) {\n      return random.rnd(min)\n    }\n    min = Math.floor(min)\n    max = Math.floor(max)\n    return min + random.rnd(1 + max - min)\n  },\n  /**\n   * get random string\n   * @method tools.random.number\n   * @param {number} [length=8]\n   * @param {Array} [set=abcdefghijklmnopqrstuvwxyz]\n   * @return {string}\n   */\n  string: function (length = 8, set = 'abcdefghijklmnopqrstuvwxyz') {\n    let _str = ''\n    for (let i = 0; i < length; i++) {\n      _str += random.element(set)\n    }\n    return _str\n  },\n  /**\n   * get random hex string\n   * @method tools.random.hex\n   * @param {number} [length=8]\n   * @return {string}\n   */\n  hex: function (length = 8) {\n    return random.string(length, '0123456789abcdef')\n  },\n  /**\n   * get random hash string\n   * @method tools.random.hash\n   * @param {?string} salt\n   * @return {string}\n   */\n  hash: function (salt = '') {\n    return hash.sha256(new Date().toISOString() + salt)\n  },\n  /**\n   * get random element from array\n   * @method tools.random.hash\n   * @param {Array<*>} array\n   * @param {Array<*>} not\n   * @return {*} element\n   */\n  element: function (array, not) {\n    if (!not) {\n      return array[random.number(0, array.length - 1)]\n    } else {\n      let _item\n      let i = 0\n      do {\n        _item = random.element(array)\n      } while (not.indexOf(_item) !== -1 && ++i < array.length)\n      return _item\n    }\n  }\n}\n\nmodule.exports = random\n","/**\n * @namespace tools.string\n */\nconst string = {\n  /**\n   * replace placeholders inside graph brackets {} with obj dictionary\n   * ~ES6 template string\n   * @param {string} str\n   * @param {Object} obj\n   * @param {boolean=} remove missing placeholders from obj, default false\n   * @return {string}\n   *\n   * @test.case 'hi {name} how are you?', {name: 'Alice'} > 'hi Alice how are you?'\n   * @test.case 'hi {name} how are you?', {}, true > 'hi  how are you?'\n   * @test.case '{a} one, 2 {b}', {a: 1, b: 'two', c: 3} > '1 one, 2 two'\n   * @test.case `multiline {1}\\n multiline`, {1: 'one'} > `multiline one\\n multiline`\n   * @test.case '<div class=\"{color}\">My name is {name} I was born in {year} and my favourite color is {color}</div>{nothing}', {name: 'Alice',year: 2014,color: 'purple'}\n   * > '<div class=\"purple\">My name is Alice I was born in 2014 and my favourite color is purple</div>{nothing}'\n   */\n  template: function (str, obj, remove = false) {\n    if (!str) {\n      return ''\n    }\n    return str.replace(/\\{([\\w.]+)\\}/g, function (str, key) {\n      return obj[key] ? obj[key] : (remove ? '' : str)\n    })\n  },\n\n  /**\n   * trim string\n   * @see http://google.github.io/closure-library/api/namespace_goog_string.html\n   * @param {string} str\n   * @param {?string[]} cuts\n   * @return {string}\n   *\n   * @test.case ' regular trim      ' > 'regular trim'\n   * @test.case ' trim,no,. : \\n    ', [',','.',' ', ':', '\\n'] > 'trim,no'\n   * @test.case ' trim string naneno', ['na','ne','no', ' '] > 'trim string'\n   * @test.case '({cut these silly brackets please)}', ['{', '}', '(', ')'] > 'cut these silly brackets please'\n   */\n  trim: function (str, cuts) {\n    if (!cuts) {\n      return str.replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, '')\n    } else {\n      var _cuts = cuts.join()\n      return str.replace(new RegExp('^[' + _cuts + ']+|[' + _cuts + ']+$', 'gm'), '')\n    }\n  },\n\n  /**\n   * @param {string} str\n   * @param {string} from\n   * @param {string} to\n   * @return {string}\n   * @test.case 'abcadaeafaga', 'a', '' > 'bcdefg'\n   * @test.case '112233445544', '4', '9' > '112233995599'\n   * @test.case 'repeat repeat repeat', 'repeat', 'don\\'t repeat' > 'don\\'t repeat don\\'t repeat don\\'t repeat'\n   * @test.case 'no replace all in js native code that replace all the replace', ' ', '_' >\n   * 'no_replace_all_in_js_native_code_that_replace_all_the_replace'\n   */\n  replaceAll: function (str, from, to) {\n    return str.split(from).join(to)\n  },\n\n  /**\n   * @param {string} str\n   * @return {string}\n   * @test.case 'alice' > 'Alice'\n   * @test.case 'alice smith' > 'Alice smith'\n   * @test.case 'alice-smith' > 'Alice-smith'\n   */\n  capitalize: function (str) {\n    return str.substr(0, 1).toUpperCase() + str.substr(1).toLowerCase()\n  },\n\n  /**\n   * @param {string} prefix\n   * @param {string} str\n   * @return {string}\n   * @test.case 'miss ', 'Alice' > 'miss Alice'\n   * @test.case 'miss ', 'miss Alice' > 'miss Alice'\n   */\n  prependMissing: function (prefix, str) {\n    if (str.indexOf(prefix) === 0) {\n      return str\n    }\n    return prefix + str\n  },\n\n  /**\n   * @param {string} str\n   * @param {RegExp} regexp\n   * @return {string[]}\n   */\n  matchAll: function (str, regexp) {\n    const _matches = []\n    let _match = regexp.exec(str)\n    while (_match) {\n      _matches.push(_match)\n      _match = regexp.exec(str)\n    }\n    return _matches\n  }\n}\n\nmodule.exports = string\n","const time = require('./time')\nconst array = require('./array')\n\n/**\n * @namespace tools.task\n */\n\n/**\n * simple async parallel task manager\n * @constructor\n * @param {object} options\n * @param {function} options.done callback when all tasks are completed\n */\nconst Tasks = function (options = {}) {\n  const __tasks = []\n\n  return {\n    /**\n     * add task\n     * @param {string} id\n     */\n    todo: function (id) {\n      if (options.chrono) {\n        time.chrono.set(id)\n      }\n      __tasks.push(id)\n    },\n    /**\n     * declare task it's done\n     * @param {string} id\n     */\n    done: function (id) {\n      array.remove(__tasks, id)\n      if (__tasks.length < 1) {\n        if (options.done) {\n          options.done()\n        }\n      }\n      if (options.chrono) {\n        const _time = time.chrono.get(id)\n        time.chrono.clear(id)\n        return {chrono: _time}\n      }\n    }\n  }\n}\n\nmodule.exports = Tasks\n","const object = require('./object')\n\n/**\n * @namespace tools.time\n */\n\nconst time = {\n  /**\n   * can use across modules using same tag\n   */\n  chrono: {\n    /**\n     * @param {?string} [tag=chrono]\n     */\n    set: function (tag = 'chrono') {\n      _chronos[tag] = Date.now()\n    },\n    /**\n     * @param {?string} [tag=chrono]\n     */\n    reset: function (tag = 'chrono') {\n      _chronos[tag] = Date.now()\n    },\n    /**\n     * @param {?string} [tag=chrono]\n     */\n    clear: function (tag = 'chrono') {\n      delete _chronos[tag]\n    },\n    /**\n     * @param {?string} [tag=chrono]\n     * @return {number} ms\n     */\n    get: function (tag = 'chrono') {\n      const _now = Date.now()\n      return _chronos[tag] ? _now - _chronos[tag] : 0\n    }\n  },\n\n  /**\n   * clear counters\n   * if you care about memory leaks\n   */\n  gc: function () {\n    object.empty(_chronos)\n  }\n}\n\nconst _chronos = {}\n\nmodule.exports = time\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvX2luZGV4LmpzIiwic3JjL2FycmF5LmpzIiwic3JjL2hhc2guanMiLCJzcmMvb2JqZWN0LmpzIiwic3JjL3JhbmRvbS5qcyIsInNyYy9zdHJpbmcuanMiLCJzcmMvdGFzay5qcyIsInNyYy90aW1lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIndpbmRvdy50b29scz17XG5hcnJheTogcmVxdWlyZSgnLi9hcnJheScpLFxuaGFzaDogcmVxdWlyZSgnLi9oYXNoJyksXG5vYmplY3Q6IHJlcXVpcmUoJy4vb2JqZWN0JyksXG5yYW5kb206IHJlcXVpcmUoJy4vcmFuZG9tJyksXG5zdHJpbmc6IHJlcXVpcmUoJy4vc3RyaW5nJyksXG50YXNrOiByZXF1aXJlKCcuL3Rhc2snKSxcbnRpbWU6IHJlcXVpcmUoJy4vdGltZScpXG59IiwiLyoqXG4gKiBhcnJheSB1dGlscywgaW5zcGlyZWQgdG8gZ29vZy5hcnJheVxuICogQG5hbWVzcGFjZSB0b29scy5hcnJheVxuICovXG5jb25zdCBhcnJheSA9IHtcbiAgLyoqXG4gICAqIEBtZXRob2QgdG9vbHMuYXJyYXkucmVtb3ZlXG4gICAqIHJlbW92ZSBhbiBlbGVtZW50IGZyb20gYXJyYXksIG9ubHkgb25jZVxuICAgKiBAdG9kbyBpdGVtPW9iamVjdCwgZGF0ZSwgcmVnZXhwIC4uLlxuICAgKiBAdG9kbyByZW1vdmUgYWxsIGl0ZW0sIG5vdCBvbmx5IGZpcnN0XG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGFycmF5XG4gICAqIEBwYXJhbSB7Kn0gaXRlbVxuICAgKiBAdGVzdC5jYXNlIFsxLDIsM10sIDIgPiAmWzEsM11cbiAgICogQHRlc3QuY2FzZSBbMSwyLDNdLCAzID4gJlsxLDJdXG4gICAqIEB0ZXN0LmNhc2UgWydqcycsJ3J1YnknLCdweXRob24nXSwgMSA+ICZbJ2pzJywncHl0aG9uJ11cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGFycmF5LCBpdGVtKSB7XG4gICAgY29uc3QgX2luZGV4ID0gYXJyYXkuaW5kZXhPZihpdGVtKVxuICAgIGlmIChfaW5kZXggIT09IC0xKSB7XG4gICAgICBhcnJheS5zcGxpY2UoX2luZGV4LCAxKVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIHJlbW92ZSBhbiBlbGVtZW50IGZyb20gYXJyYXkgYXQgcG9zaXRpb25cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gYXJyYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEB0ZXN0LmNhc2UgWzEsMiwzXSwgMCA+ICZbMiwzXVxuICAgKiBAdGVzdC5jYXNlIFsxLDIsM10sIDEgPiAmWzEsM11cbiAgICogQHRlc3QuY2FzZSBbMSwyLDNdLCAtMSA+ICZbMSwyXVxuICAgKiBAdGVzdC5jYXNlIFsxLDIsM10sIDQgPiAmWzEsMiwzXVxuICAgKi9cbiAgcmVtb3ZlQXQ6IGZ1bmN0aW9uIChhcnJheSwgaW5kZXgpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSkubGVuZ3RoID09PSAxXG4gIH0sXG4gIC8qKlxuICAgKiBnZXQgbGFzdCBlbGVtZW50IG9mIGFycmF5IG9yIHVuZGVmaW5lZFxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBhcnJheVxuICAgKiBAcmV0dXJuIHsqfSBsYXN0IGVsZW1lbnQgb2YgdGhlIGFycmF5IG9yIHVuZGVmaW5lZFxuICAgKiBAdGVzdC5jYXNlIFsxLDIsM10gPiAzXG4gICAqIEB0ZXN0LmNhc2UgW251bGwsIDAsIC0xXSA+IC0xXG4gICAqIEB0ZXN0LmNhc2UgW251bGxdID4gbnVsbFxuICAgKiBAdGVzdC5jYXNlIFswXSA+IDBcbiAgICogQHRlc3QuY2FzZSBbXSA+IHVuZGVmaW5lZFxuICAgKiBAdGVzdC5jYXNlIFsxLCB1bmRlZmluZWRdID4gdW5kZWZpbmVkXG4gICAqL1xuICBsYXN0OiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV1cbiAgfSxcbiAgLyoqXG4gICAqIGdldCBudGggZWxlbWVudCBvZiBhcnJheVxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBhcnJheVxuICAgKiBAcmV0dXJuIHsqfSBudGggZWxlbWVudCBvZiBhcnJheTsgaWYgbmVnYXRpdmUsIHN0YXJ0IGZyb20gZW5kOiAtMSA9IGxhc3QgZWxlbWVudDsgdW5kZWZpbmVkIGlmIG1pc3NpbmdcbiAgICogQHRlc3QuY2FzZSBbMSwyLDNdLCAwID4gMVxuICAgKiBAdGVzdC5jYXNlIFswLDEsbnVsbCwzXSwgMCA+IDBcbiAgICogQHRlc3QuY2FzZSBbMCwxLG51bGwsZmFsc2VdLCAtMSA+IGZhbHNlXG4gICAqIEB0ZXN0LmNhc2UgWzAsMSxudWxsLGZhbHNlXSwgLTIgPiBudWxsXG4gICAqIEB0ZXN0LmNhc2UgWzAsMSwnMCcsZmFsc2VdLCAtMiA+ICcwJ1xuICAgKiBAdGVzdC5jYXNlIFt1bmRlZmluZWQsJzAnLGZhbHNlXSwgMCA+IHVuZGVmaW5lZFxuICAgKiBAdGVzdC5jYXNlIFtdLCAyID4gdW5kZWZpbmVkXG4gICAqL1xuICBhdDogZnVuY3Rpb24gKGFycmF5LCBwKSB7XG4gICAgaWYgKHAgPCAwKSB7XG4gICAgICBwID0gYXJyYXkubGVuZ3RoICsgcFxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlbcF1cbiAgfSxcbiAgLyoqXG4gICAqIGdldCBmaXJzdCBlbGVtZW50IG9mIGFycmF5IG9yIHVuZGVmaW5lZFxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBhcnJheVxuICAgKiBAcmV0dXJuIHsqfSBmaXJzdCBlbGVtZW50IG9mIHRoZSBhcnJheSBvciB1bmRlZmluZWRcbiAgICogQHRlc3QuY2FzZSBbMSwyLDNdID4gMVxuICAgKiBAdGVzdC5jYXNlIFswLDEsbnVsbCwzXSA+IDBcbiAgICogQHRlc3QuY2FzZSBbMSxudWxsLGZhbHNlXSA+IDFcbiAgICogQHRlc3QuY2FzZSBbbnVsbCxmYWxzZV0gPiBudWxsXG4gICAqIEB0ZXN0LmNhc2UgW3VuZGVmaW5lZCwnMCcsZmFsc2VdID4gdW5kZWZpbmVkXG4gICAqIEB0ZXN0LmNhc2UgW10gPiB1bmRlZmluZWRcbiAgICovXG4gIGZpcnN0OiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXlbMF1cbiAgfSxcbiAgLyoqXG4gICAqIGNoZWNrIGlmIGFycmF5IGNvbnRhaW5zIGFuIGVsZW1lbnRcbiAgICogQHBhcmFtIHtBcnJheTwqPn0gYXJyYXlcbiAgICogQHBhcmFtIHsqfSBpdGVtXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWluczogZnVuY3Rpb24gKGFycmF5LCBpdGVtKSB7XG4gICAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgIT09IC0xXG4gIH0sXG4gIC8qKlxuICAgKiBpbnNlcnQgYW4gaXRlbSBpbnRvIGFycmF5IGF0IGluZGV4IHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGFycmF5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0geyp9IGl0ZW1cbiAgICogQHRlc3QuY2FzZSBbJ2pvaG4nLCAnYWxpY2UnLCAnYm9iJ10sIDAsICdtYXJ5JyA+ICZbJ21hcnknLCAnam9obicsICdhbGljZScsICdib2InXVxuICAgKiBAdGVzdC5jYXNlIFsnam9obicsICdhbGljZScsICdib2InXSwgMSwgJ21hcnknID4gJlsnam9obicsICdtYXJ5JywgJ2FsaWNlJywgJ2JvYiddXG4gICAqIEB0ZXN0LmNhc2UgWydqb2huJywgJ2FsaWNlJywgJ2JvYiddLCAtMSwgJ21hcnknID4gJlsnam9obicsICdhbGljZScsICdib2InLCAnbWFyeSddXG4gICAqIEB0ZXN0LmNhc2UgWydqb2huJywgJ2FsaWNlJywgJ2JvYiddLCAtMiwgJ21hcnknID4gJlsnam9obicsICdhbGljZScsICdtYXJ5JywgJ2JvYiddXG4gICAqL1xuICBpbnNlcnQ6IGZ1bmN0aW9uIChhcnJheSwgaW5kZXgsIGl0ZW0pIHtcbiAgICBpZiAoaW5kZXggPiBhcnJheS5sZW5ndGgpIHtcbiAgICAgIGluZGV4ID0gYXJyYXkubGVuZ3RoXG4gICAgfVxuXG4gICAgaWYgKGFycmF5W2luZGV4XSkge1xuICAgICAgYXJyYXkuc3BsaWNlKGluZGV4LCAwLCBpdGVtKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBpdGVtXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBjb25jYXQgYXJyYXlzXG4gICAqIEBwYXJhbSB7Li4uQXJyYXk8Kj59IGFycmF5cyB0byBjaGFpblxuICAgKiBAcmV0dXJuIHtBcnJheTwqPn0gY2hhaW5lZCBhcnJheXNcbiAgICogQHRlc3QuY2FzZSBbMCwxLDJdLFszLDQsNV0gPiBbMCwxLDIsMyw0LDVdXG4gICAqIEB0ZXN0LmNhc2UgWzAsIDEsIDIsIDNdLCBbJ2EnLCAnYicsICdjJ10sIFt7YTogMn1dID4gWzAsIDEsIDIsIDMsICdhJywgJ2InLCAnYycsIHthOiAyfV1cbiAgICovXG4gIGNvbmNhdDogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShBcnJheS5wcm90b3R5cGUsIGFyZ3VtZW50cylcbiAgfSxcbiAgLyoqXG4gICAqIGVtcHR5IGFycmF5IC0gbmVlZCB0byBrZWVwIHJlZmVyZW5jZXNcbiAgICogQHRlc3QuY2FzZSBbMCwxLDJdID4gJltdXG4gICAqIEB0ZXN0LmNhc2UgW10gPiAmW11cbiAgICovXG4gIGVtcHR5OiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB3aGlsZSAoYXJyYXlbMF0pIHtcbiAgICAgIGFycmF5LnBvcCgpXG4gICAgfVxuICB9LFxuICAvKipcbiAgICogcHVzaCBpdGVtIGludG8gYXJyYXksIG9wdGlvbmFsbHkgY2hlY2sgaWYgYWxyZWFkeSBleGlzdHNcbiAgICovXG4gIGFkZDogZnVuY3Rpb24gKGFycmF5LCBpdGVtLCB1bmlxdWUpIHtcbiAgICBpZiAodW5pcXVlICYmIGFycmF5LmNvbnRhaW5zKGFycmF5LCBpdGVtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGFycmF5LnB1c2goaXRlbSlcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlcbiIsIi8vY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcblxuLyoqXG4gKiBAbmFtZXNwYWNlIHRvb2xzLmhhc2hcbiAqL1xuY29uc3QgaGFzaCA9IHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlIGhhc2ggdXNpbmcgc2hhMjU2IGluIGhleCBmb3JtYXRcbiAgICogQG1ldGhvZCB0b29scy5oYXNoLnNoYTI1NlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YSBhbnkgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc2hhMjU2IGluIGhleCBmb3JtYXRcbiAgICpcbiAgICogQHRlc3RcbiAgICogJ3VzazZmZ2J1eWdidTYnID4gJ2VlNDJmNjE5OTE5NzI3NTg0YjY2ZmUyNTI0OGVkNGJiYThlODdkY2ZiM2U2MmE5MDE0M2VhMTdiYTQ4ZGY1OGUnXG4gICAqIEB0ZXN0XG4gICAqICdsb3JlbSBpcHN1bSAlMTI4Mzc3MHR2OGd2IDZjNmZndyB1Y3RodiBpeSdcbiAgICogPiAnMThkMThjMjZlZDk4YzBlODhkOTEyMTEzMmJlNDhmNDI1OTZlODk5YWM1MGYxNWY4NTRjOWQwYTgyYjlmMmNiNSdcbiAgICovXG4gIHNoYTI1NjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpXG4gICAgICAudXBkYXRlKGRhdGEpXG4gICAgICAuZGlnZXN0KCdoZXgnKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFxuIiwiLyoqXG4gKiBAbmFtZXNwYWNlIHRvb2xzLm9iamVjdFxuICovXG5jb25zdCBvYmplY3QgPSB7XG4gIC8qKlxuICAgKiBtZXJnZSBvYmoyIGludG8gb2JqMVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqMVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqMlxuICAgKiBAdGVzdC5jYXNlIHthOiAxLCBiOiAnY2lhbyd9LCB7YTogNCwgYzogeyBkOiA4LCBlOiA5fX0gPiAmeyBhOiA0LCBiOiAnY2lhbycsIGM6IHsgZDogOCwgZTogOSB9IH1cbiAgICovXG4gIG1lcmdlOiBmdW5jdGlvbiAob2JqMSwgb2JqMikge1xuICAgIGlmICghb2JqMSkge1xuICAgICAgb2JqMSA9IG9iajIgfHwge31cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoIW9iajIpIHtcbiAgICAgIHJldHVybiBvYmoxXG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSBpbiBvYmoyKSB7XG4gICAgICBpZiAodHlwZW9mIG9iajJbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChvYmoyW2ldIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICBvYmoxW2ldID0gb2JqZWN0LmNsb25lKG9iajJbaV0pXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9iajFbaV0gfHwgdHlwZW9mIG9iajFbaV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgb2JqMVtpXSA9IHt9XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0Lm1lcmdlKG9iajFbaV0sIG9iajJbaV0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmoxW2ldID0gb2JqMltpXVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIENsb25lIGFuIGFycmF5IG9yIGFuIG9iamVjdCBpbiBpbnB1dFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgYXJyYXkgb3IgdGhlIG9iamVjdCB0byBjbG9uZVxuICAgKiBAcmV0dXJuIHtPYmplY3R8QXJyYXl9XG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBvYmpcbiAgICB9XG4gICAgdmFyIF90eXBlID0gKG9iaiBpbnN0YW5jZW9mIEFycmF5KSA/ICdhcnJheScgOiB0eXBlb2Ygb2JqXG4gICAgaWYgKF90eXBlID09PSAnb2JqZWN0JyB8fCBfdHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iai5nZXRUaW1lKCkpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBvYmpcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvYmouY2xvbmUpIHtcbiAgICAgICAgICByZXR1cm4gb2JqLmNsb25lKClcbiAgICAgICAgfVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0eXBlIHtBcnJheXxPYmplY3R9XG4gICAgICAgICAgICovXG4gICAgICAgIHZhciBfY2xvbmUgPSBfdHlwZSA9PT0gJ2FycmF5JyA/IFtdIDoge31cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgIF9jbG9uZVtrZXldID0gb2JqZWN0LmNsb25lKG9ialtrZXldKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfY2xvbmVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9LFxuICAvKipcbiAgICogQHNlZSBodHRwOi8vZ29vZ2xlLmdpdGh1Yi5pby9jbG9zdXJlLWxpYnJhcnkvYXBpL3NvdXJjZS9jbG9zdXJlL2dvb2cvb2JqZWN0L29iamVjdC5qcy5zcmMuaHRtbCNsMjI1XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBnZXRLZXlzOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICAgIH1cbiAgICB2YXIgX2tleXMgPSBbXVxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIF9rZXlzLnB1c2goa2V5KVxuICAgIH1cbiAgICByZXR1cm4gX2tleXNcbiAgfSxcblxuICAvKipcbiAgICogQHRvZG8gY2hlY2sgaWYgYm90aCBhcmUgb2JqZWN0c1xuICAgKi9cbiAgaW5oZXJpdHM6IGZ1bmN0aW9uIChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgICAvLyAgICAgIHV0aWwuaW5oZXJpdHMoZGVzdGluYXRpb24sIHNvdXJjZSlcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UpLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBzb3VyY2VbcHJvcGVydHldXG4gICAgfSlcbiAgfSxcblxuICAvKipcbiAgICogZW1wdHkgb2JqZWN0IC0gbmVlZCB0byBrZWVwIHJlZmVyZW5jZXNcbiAgICogQHRlc3QuY2FzZSB7YTowLGI6MSxjOjIsZDpbXSxlOntmOi0xfX0gPiAme31cbiAgICogQHRlc3QuY2FzZSB7fSA+ICZ7fVxuICAgKi9cbiAgZW1wdHk6IGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gb2JqKSB7XG4gICAgICBkZWxldGUgb2JqW2ldXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBmbGF0IGtleXMgaW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICogQHRlc3QuY2FzZSB7IGE6IHsgYTE6IDEsIGEyOiAyIH0sIGI6IDMgfSA+IHsgJ2EuYTEnOiAxLCAnYS5hMic6IDIsICdiJzogMyB9XG4gICAqL1xuICBmbGF0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgY29uc3QgX2ZsYXQgPSB7fVxuXG4gICAgY29uc3QgX2YgPSBmdW5jdGlvbiAob2JqLCBiYXNlKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgICAgaWYgKG9ialtrZXldLmNvbnN0cnVjdG9yID09IE9iamVjdCkge1xuICAgICAgICAgICAgX2Yob2JqW2tleV0sIGJhc2UgKyBrZXkgKyAnLicpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9mbGF0W2Jhc2UgKyBrZXldID0gb2JqW2tleV1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBfZmxhdFtiYXNlICsga2V5XSA9IG9ialtrZXldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX2Yob2JqLCAnJylcblxuICAgIHJldHVybiBfZmxhdFxuICB9LFxuICAvKipcbiAgICogcmVzdG9yZSBmbGF0IG9iamVjdFxuICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqIEB0ZXN0LmNhc2UgeyAnYS5hMSc6IDEsICdhLmEyJzogMiwgJ2InOiAzIH0gPiB7IGE6IHsgYTE6IDEsIGEyOiAyIH0sIGI6IDMgfVxuICAgKi9cbiAgcmFpc2U6IGZ1bmN0aW9uIChvYmopIHtcbiAgICBjb25zdCBfcmFpc2UgPSB7fVxuXG4gICAgY29uc3QgX2YgPSBmdW5jdGlvbiAoZmxhdCwgcmFpc2UpIHtcbiAgICAgIGZvciAoY29uc3QgcGF0aCBpbiBmbGF0KSB7XG4gICAgICAgIGNvbnN0IF9rZXlzID0gcGF0aC5zcGxpdCgnLicpXG4gICAgICAgIGxldCBfY3Vyc29yID0gcmFpc2VcbiAgICAgICAgX2tleXMuZm9yRWFjaCgoa2V5LCBpKSA9PiB7XG4gICAgICAgICAgaWYgKGkgPCBfa2V5cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBpZiAoIV9jdXJzb3Jba2V5XSkge1xuICAgICAgICAgICAgICBfY3Vyc29yW2tleV0gPSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2N1cnNvciA9IF9jdXJzb3Jba2V5XVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfY3Vyc29yW2tleV0gPSBmbGF0W3BhdGhdXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICBfZihvYmosIF9yYWlzZSlcblxuICAgIHJldHVybiBfcmFpc2VcbiAgfSxcbiAgLyoqXG4gICAqIGdldCB2YWx1ZSBpbiBvYmplY3QgdXNpbmcgYSBmbGF0IGtleVxuICAgKiBAdG9kbyBjaGVjayBwYXJhbXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmtleVxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKiBAdGVzdC5jYXNlIHsgYTogeyBiOiB7YzogMX0gfSB9LCAnYS5iLmMnID4gMVxuICAgKi9cbiAgZ2V0QnlGbGF0S2V5OiBmdW5jdGlvbiAob2JqLCBma2V5KSB7XG4gICAgbGV0IF9wYXRoID0gZmtleS5zcGxpdCgnLicpXG4gICAgbGV0IF93YWxrID0gb2JqXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFfd2Fsa1tfcGF0aFtpXV0pIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgfVxuICAgICAgX3dhbGsgPSBfd2Fsa1tfcGF0aFtpXV1cbiAgICB9XG4gICAgcmV0dXJuIF93YWxrXG4gIH0sXG5cbiAgLyoqXG4gICAqIHNldCB2YWx1ZSBpbiBvYmplY3QgdXNpbmcgYSBmbGF0IGtleVxuICAgKiBAdG9kbyBjaGVjayBwYXJhbXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmtleVxuICAgKiBAcGFyYW0geyp9IHZhbFxuICAgKiBAdGVzdC5jYXNlXG4gICAqIHt9LCAnYS5iLmMnLCAxID4gJnsgYTogeyBiOiB7YzogMX0gfSB9XG4gICAqL1xuICBzZXRCeUZsYXRLZXk6IGZ1bmN0aW9uIChvYmosIGZrZXksIHZhbCkge1xuICAgIGxldCBfcGF0aCA9IGZrZXkuc3BsaXQoJy4nKVxuICAgIGxldCBfd2FsayA9IG9ialxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX3BhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghX3dhbGtbX3BhdGhbaV1dKSB7XG4gICAgICAgICAgLy8gaWYgaXQncyB0aGUgbGFzdCBzdGVwLCBhZGQga2V5IGFzIHVuZGVmaW5lZFxuICAgICAgICBpZiAoaSA9PT0gX3BhdGgubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIF93YWxrW19wYXRoW2ldXSA9IHVuZGVmaW5lZFxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIF93YWxrW19wYXRoW2ldXSA9IHt9XG4gICAgICB9XG4gICAgICBfd2FsayA9IF93YWxrW19wYXRoW2ldXVxuICAgIH1cbiAgICBfd2FsayA9IHZhbFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0XG4iLCJjb25zdCBoYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxuLyoqXG4gKiBAbmFtZXNwYWNlIHRvb2xzLnJhbmRvbVxuICovXG5jb25zdCByYW5kb20gPSB7XG4gIC8qKlxuICAgKiBnZXQgcmFuZG9tIGludCBmcm9tIDAgdG8gbWF4XG4gICAqIEBtZXRob2QgdG9vbHMucmFuZG9tLnJuZFxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJuZDogZnVuY3Rpb24gKG1heCkge1xuICAgIGlmICghbWF4KSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICByZXR1cm4gTWF0aC5mbG9vcihtYXggKiBNYXRoLnJhbmRvbSgpKVxuICB9LFxuICAvKipcbiAgICogZ2V0IHJhbmRvbSBpbnQgZnJvbSBtaW4gdG8gbWF4XG4gICAqIEBtZXRob2QgdG9vbHMucmFuZG9tLm51bWJlclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgbnVtYmVyOiBmdW5jdGlvbiAobWluLCBtYXgpIHtcbiAgICBpZiAoIW1heCkge1xuICAgICAgcmV0dXJuIHJhbmRvbS5ybmQobWluKVxuICAgIH1cbiAgICBtaW4gPSBNYXRoLmZsb29yKG1pbilcbiAgICBtYXggPSBNYXRoLmZsb29yKG1heClcbiAgICByZXR1cm4gbWluICsgcmFuZG9tLnJuZCgxICsgbWF4IC0gbWluKVxuICB9LFxuICAvKipcbiAgICogZ2V0IHJhbmRvbSBzdHJpbmdcbiAgICogQG1ldGhvZCB0b29scy5yYW5kb20ubnVtYmVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPThdXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtzZXQ9YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpdXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHN0cmluZzogZnVuY3Rpb24gKGxlbmd0aCA9IDgsIHNldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicpIHtcbiAgICBsZXQgX3N0ciA9ICcnXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgX3N0ciArPSByYW5kb20uZWxlbWVudChzZXQpXG4gICAgfVxuICAgIHJldHVybiBfc3RyXG4gIH0sXG4gIC8qKlxuICAgKiBnZXQgcmFuZG9tIGhleCBzdHJpbmdcbiAgICogQG1ldGhvZCB0b29scy5yYW5kb20uaGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPThdXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGhleDogZnVuY3Rpb24gKGxlbmd0aCA9IDgpIHtcbiAgICByZXR1cm4gcmFuZG9tLnN0cmluZyhsZW5ndGgsICcwMTIzNDU2Nzg5YWJjZGVmJylcbiAgfSxcbiAgLyoqXG4gICAqIGdldCByYW5kb20gaGFzaCBzdHJpbmdcbiAgICogQG1ldGhvZCB0b29scy5yYW5kb20uaGFzaFxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHNhbHRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgaGFzaDogZnVuY3Rpb24gKHNhbHQgPSAnJykge1xuICAgIHJldHVybiBoYXNoLnNoYTI1NihuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyBzYWx0KVxuICB9LFxuICAvKipcbiAgICogZ2V0IHJhbmRvbSBlbGVtZW50IGZyb20gYXJyYXlcbiAgICogQG1ldGhvZCB0b29scy5yYW5kb20uaGFzaFxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBhcnJheVxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBub3RcbiAgICogQHJldHVybiB7Kn0gZWxlbWVudFxuICAgKi9cbiAgZWxlbWVudDogZnVuY3Rpb24gKGFycmF5LCBub3QpIHtcbiAgICBpZiAoIW5vdCkge1xuICAgICAgcmV0dXJuIGFycmF5W3JhbmRvbS5udW1iZXIoMCwgYXJyYXkubGVuZ3RoIC0gMSldXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBfaXRlbVxuICAgICAgbGV0IGkgPSAwXG4gICAgICBkbyB7XG4gICAgICAgIF9pdGVtID0gcmFuZG9tLmVsZW1lbnQoYXJyYXkpXG4gICAgICB9IHdoaWxlIChub3QuaW5kZXhPZihfaXRlbSkgIT09IC0xICYmICsraSA8IGFycmF5Lmxlbmd0aClcbiAgICAgIHJldHVybiBfaXRlbVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbmRvbVxuIiwiLyoqXG4gKiBAbmFtZXNwYWNlIHRvb2xzLnN0cmluZ1xuICovXG5jb25zdCBzdHJpbmcgPSB7XG4gIC8qKlxuICAgKiByZXBsYWNlIHBsYWNlaG9sZGVycyBpbnNpZGUgZ3JhcGggYnJhY2tldHMge30gd2l0aCBvYmogZGljdGlvbmFyeVxuICAgKiB+RVM2IHRlbXBsYXRlIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHBhcmFtIHtib29sZWFuPX0gcmVtb3ZlIG1pc3NpbmcgcGxhY2Vob2xkZXJzIGZyb20gb2JqLCBkZWZhdWx0IGZhbHNlXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICpcbiAgICogQHRlc3QuY2FzZSAnaGkge25hbWV9IGhvdyBhcmUgeW91PycsIHtuYW1lOiAnQWxpY2UnfSA+ICdoaSBBbGljZSBob3cgYXJlIHlvdT8nXG4gICAqIEB0ZXN0LmNhc2UgJ2hpIHtuYW1lfSBob3cgYXJlIHlvdT8nLCB7fSwgdHJ1ZSA+ICdoaSAgaG93IGFyZSB5b3U/J1xuICAgKiBAdGVzdC5jYXNlICd7YX0gb25lLCAyIHtifScsIHthOiAxLCBiOiAndHdvJywgYzogM30gPiAnMSBvbmUsIDIgdHdvJ1xuICAgKiBAdGVzdC5jYXNlIGBtdWx0aWxpbmUgezF9XFxuIG11bHRpbGluZWAsIHsxOiAnb25lJ30gPiBgbXVsdGlsaW5lIG9uZVxcbiBtdWx0aWxpbmVgXG4gICAqIEB0ZXN0LmNhc2UgJzxkaXYgY2xhc3M9XCJ7Y29sb3J9XCI+TXkgbmFtZSBpcyB7bmFtZX0gSSB3YXMgYm9ybiBpbiB7eWVhcn0gYW5kIG15IGZhdm91cml0ZSBjb2xvciBpcyB7Y29sb3J9PC9kaXY+e25vdGhpbmd9Jywge25hbWU6ICdBbGljZScseWVhcjogMjAxNCxjb2xvcjogJ3B1cnBsZSd9XG4gICAqID4gJzxkaXYgY2xhc3M9XCJwdXJwbGVcIj5NeSBuYW1lIGlzIEFsaWNlIEkgd2FzIGJvcm4gaW4gMjAxNCBhbmQgbXkgZmF2b3VyaXRlIGNvbG9yIGlzIHB1cnBsZTwvZGl2Pntub3RoaW5nfSdcbiAgICovXG4gIHRlbXBsYXRlOiBmdW5jdGlvbiAoc3RyLCBvYmosIHJlbW92ZSA9IGZhbHNlKSB7XG4gICAgaWYgKCFzdHIpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xceyhbXFx3Ll0rKVxcfS9nLCBmdW5jdGlvbiAoc3RyLCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA/IG9ialtrZXldIDogKHJlbW92ZSA/ICcnIDogc3RyKVxuICAgIH0pXG4gIH0sXG5cbiAgLyoqXG4gICAqIHRyaW0gc3RyaW5nXG4gICAqIEBzZWUgaHR0cDovL2dvb2dsZS5naXRodWIuaW8vY2xvc3VyZS1saWJyYXJ5L2FwaS9uYW1lc3BhY2VfZ29vZ19zdHJpbmcuaHRtbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqIEBwYXJhbSB7P3N0cmluZ1tdfSBjdXRzXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICpcbiAgICogQHRlc3QuY2FzZSAnIHJlZ3VsYXIgdHJpbSAgICAgICcgPiAncmVndWxhciB0cmltJ1xuICAgKiBAdGVzdC5jYXNlICcgdHJpbSxubywuIDogXFxuICAgICcsIFsnLCcsJy4nLCcgJywgJzonLCAnXFxuJ10gPiAndHJpbSxubydcbiAgICogQHRlc3QuY2FzZSAnIHRyaW0gc3RyaW5nIG5hbmVubycsIFsnbmEnLCduZScsJ25vJywgJyAnXSA+ICd0cmltIHN0cmluZydcbiAgICogQHRlc3QuY2FzZSAnKHtjdXQgdGhlc2Ugc2lsbHkgYnJhY2tldHMgcGxlYXNlKX0nLCBbJ3snLCAnfScsICcoJywgJyknXSA+ICdjdXQgdGhlc2Ugc2lsbHkgYnJhY2tldHMgcGxlYXNlJ1xuICAgKi9cbiAgdHJpbTogZnVuY3Rpb24gKHN0ciwgY3V0cykge1xuICAgIGlmICghY3V0cykge1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xceGEwXSt8W1xcc1xceGEwXSskL2csICcnKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2N1dHMgPSBjdXRzLmpvaW4oKVxuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJ15bJyArIF9jdXRzICsgJ10rfFsnICsgX2N1dHMgKyAnXSskJywgJ2dtJyksICcnKVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAdGVzdC5jYXNlICdhYmNhZGFlYWZhZ2EnLCAnYScsICcnID4gJ2JjZGVmZydcbiAgICogQHRlc3QuY2FzZSAnMTEyMjMzNDQ1NTQ0JywgJzQnLCAnOScgPiAnMTEyMjMzOTk1NTk5J1xuICAgKiBAdGVzdC5jYXNlICdyZXBlYXQgcmVwZWF0IHJlcGVhdCcsICdyZXBlYXQnLCAnZG9uXFwndCByZXBlYXQnID4gJ2RvblxcJ3QgcmVwZWF0IGRvblxcJ3QgcmVwZWF0IGRvblxcJ3QgcmVwZWF0J1xuICAgKiBAdGVzdC5jYXNlICdubyByZXBsYWNlIGFsbCBpbiBqcyBuYXRpdmUgY29kZSB0aGF0IHJlcGxhY2UgYWxsIHRoZSByZXBsYWNlJywgJyAnLCAnXycgPlxuICAgKiAnbm9fcmVwbGFjZV9hbGxfaW5fanNfbmF0aXZlX2NvZGVfdGhhdF9yZXBsYWNlX2FsbF90aGVfcmVwbGFjZSdcbiAgICovXG4gIHJlcGxhY2VBbGw6IGZ1bmN0aW9uIChzdHIsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdChmcm9tKS5qb2luKHRvKVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogQHRlc3QuY2FzZSAnYWxpY2UnID4gJ0FsaWNlJ1xuICAgKiBAdGVzdC5jYXNlICdhbGljZSBzbWl0aCcgPiAnQWxpY2Ugc21pdGgnXG4gICAqIEB0ZXN0LmNhc2UgJ2FsaWNlLXNtaXRoJyA+ICdBbGljZS1zbWl0aCdcbiAgICovXG4gIGNhcGl0YWxpemU6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cigwLCAxKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpXG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqIEB0ZXN0LmNhc2UgJ21pc3MgJywgJ0FsaWNlJyA+ICdtaXNzIEFsaWNlJ1xuICAgKiBAdGVzdC5jYXNlICdtaXNzICcsICdtaXNzIEFsaWNlJyA+ICdtaXNzIEFsaWNlJ1xuICAgKi9cbiAgcHJlcGVuZE1pc3Npbmc6IGZ1bmN0aW9uIChwcmVmaXgsIHN0cikge1xuICAgIGlmIChzdHIuaW5kZXhPZihwcmVmaXgpID09PSAwKSB7XG4gICAgICByZXR1cm4gc3RyXG4gICAgfVxuICAgIHJldHVybiBwcmVmaXggKyBzdHJcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdfVxuICAgKi9cbiAgbWF0Y2hBbGw6IGZ1bmN0aW9uIChzdHIsIHJlZ2V4cCkge1xuICAgIGNvbnN0IF9tYXRjaGVzID0gW11cbiAgICBsZXQgX21hdGNoID0gcmVnZXhwLmV4ZWMoc3RyKVxuICAgIHdoaWxlIChfbWF0Y2gpIHtcbiAgICAgIF9tYXRjaGVzLnB1c2goX21hdGNoKVxuICAgICAgX21hdGNoID0gcmVnZXhwLmV4ZWMoc3RyKVxuICAgIH1cbiAgICByZXR1cm4gX21hdGNoZXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1xuIiwiY29uc3QgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpXG5jb25zdCBhcnJheSA9IHJlcXVpcmUoJy4vYXJyYXknKVxuXG4vKipcbiAqIEBuYW1lc3BhY2UgdG9vbHMudGFza1xuICovXG5cbi8qKlxuICogc2ltcGxlIGFzeW5jIHBhcmFsbGVsIHRhc2sgbWFuYWdlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5kb25lIGNhbGxiYWNrIHdoZW4gYWxsIHRhc2tzIGFyZSBjb21wbGV0ZWRcbiAqL1xuY29uc3QgVGFza3MgPSBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IF9fdGFza3MgPSBbXVxuXG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogYWRkIHRhc2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKi9cbiAgICB0b2RvOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGlmIChvcHRpb25zLmNocm9ubykge1xuICAgICAgICB0aW1lLmNocm9uby5zZXQoaWQpXG4gICAgICB9XG4gICAgICBfX3Rhc2tzLnB1c2goaWQpXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBkZWNsYXJlIHRhc2sgaXQncyBkb25lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICovXG4gICAgZG9uZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgICBhcnJheS5yZW1vdmUoX190YXNrcywgaWQpXG4gICAgICBpZiAoX190YXNrcy5sZW5ndGggPCAxKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmRvbmUpIHtcbiAgICAgICAgICBvcHRpb25zLmRvbmUoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5jaHJvbm8pIHtcbiAgICAgICAgY29uc3QgX3RpbWUgPSB0aW1lLmNocm9uby5nZXQoaWQpXG4gICAgICAgIHRpbWUuY2hyb25vLmNsZWFyKGlkKVxuICAgICAgICByZXR1cm4ge2Nocm9ubzogX3RpbWV9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGFza3NcbiIsImNvbnN0IG9iamVjdCA9IHJlcXVpcmUoJy4vb2JqZWN0JylcblxuLyoqXG4gKiBAbmFtZXNwYWNlIHRvb2xzLnRpbWVcbiAqL1xuXG5jb25zdCB0aW1lID0ge1xuICAvKipcbiAgICogY2FuIHVzZSBhY3Jvc3MgbW9kdWxlcyB1c2luZyBzYW1lIHRhZ1xuICAgKi9cbiAgY2hyb25vOiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBbdGFnPWNocm9ub11cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uICh0YWcgPSAnY2hyb25vJykge1xuICAgICAgX2Nocm9ub3NbdGFnXSA9IERhdGUubm93KClcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gW3RhZz1jaHJvbm9dXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uICh0YWcgPSAnY2hyb25vJykge1xuICAgICAgX2Nocm9ub3NbdGFnXSA9IERhdGUubm93KClcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gW3RhZz1jaHJvbm9dXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uICh0YWcgPSAnY2hyb25vJykge1xuICAgICAgZGVsZXRlIF9jaHJvbm9zW3RhZ11cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gW3RhZz1jaHJvbm9dXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBtc1xuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKHRhZyA9ICdjaHJvbm8nKSB7XG4gICAgICBjb25zdCBfbm93ID0gRGF0ZS5ub3coKVxuICAgICAgcmV0dXJuIF9jaHJvbm9zW3RhZ10gPyBfbm93IC0gX2Nocm9ub3NbdGFnXSA6IDBcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNsZWFyIGNvdW50ZXJzXG4gICAqIGlmIHlvdSBjYXJlIGFib3V0IG1lbW9yeSBsZWFrc1xuICAgKi9cbiAgZ2M6IGZ1bmN0aW9uICgpIHtcbiAgICBvYmplY3QuZW1wdHkoX2Nocm9ub3MpXG4gIH1cbn1cblxuY29uc3QgX2Nocm9ub3MgPSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRpbWVcbiJdfQ=="}