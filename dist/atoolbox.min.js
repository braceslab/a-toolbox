(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
window.tools={
array: require('./array'),
hash: require('./hash'),
object: require('./object'),
random: require('./random'),
string: require('./string'),
task: require('./task'),
time: require('./time')
}
},{"./array":2,"./hash":3,"./object":4,"./random":5,"./string":6,"./task":7,"./time":8}],2:[function(require,module,exports){
/**
 * array utils, inspired to goog.array
 * @namespace tools.array
 */
const array = {
  /**
   * @method tools.array.remove
   * remove an element from array, only once
   * @todo item=object, date, regexp ...
   * @todo remove all item, not only first
   * @param {Array<*>} array
   * @param {*} item
   * @test.case [1,2,3], 2 > &[1,3]
   * @test.case [1,2,3], 3 > &[1,2]
   * @test.case ['js','ruby','python'], 1 > &['js','python']
   */
  remove: function (array, item) {
    const _index = array.indexOf(item)
    if (_index !== -1) {
      array.splice(_index, 1)
    }
  },
  /**
   * remove an element from array at position
   * @param {Array<*>} array
   * @param {number} index
   * @test.case [1,2,3], 0 > &[2,3]
   * @test.case [1,2,3], 1 > &[1,3]
   * @test.case [1,2,3], -1 > &[1,2]
   * @test.case [1,2,3], 4 > &[1,2,3]
   */
  removeAt: function (array, index) {
    return Array.prototype.splice.call(array, index, 1).length === 1
  },
  /**
   * get last element of array or undefined
   * @param {Array<*>} array
   * @return {*} last element of the array or undefined
   * @test.case [1,2,3] > 3
   * @test.case [null, 0, -1] > -1
   * @test.case [null] > null
   * @test.case [0] > 0
   * @test.case [] > undefined
   * @test.case [1, undefined] > undefined
   */
  last: function (array) {
    return array[array.length - 1]
  },
  /**
   * get nth element of array
   * @param {Array<*>} array
   * @return {*} nth element of array; if negative, start from end: -1 = last element; undefined if missing
   * @test.case [1,2,3], 0 > 1
   * @test.case [0,1,null,3], 0 > 0
   * @test.case [0,1,null,false], -1 > false
   * @test.case [0,1,null,false], -2 > null
   * @test.case [0,1,'0',false], -2 > '0'
   * @test.case [undefined,'0',false], 0 > undefined
   * @test.case [], 2 > undefined
   */
  at: function (array, p) {
    if (p < 0) {
      p = array.length + p
    }
    return array[p]
  },
  /**
   * get first element of array or undefined
   * @param {Array<*>} array
   * @return {*} first element of the array or undefined
   * @test.case [1,2,3] > 1
   * @test.case [0,1,null,3] > 0
   * @test.case [1,null,false] > 1
   * @test.case [null,false] > null
   * @test.case [undefined,'0',false] > undefined
   * @test.case [] > undefined
   */
  first: function (array) {
    return array[0]
  },
  /**
   * check if array contains an element
   * @param {Array<*>} array
   * @param {*} item
   * @return {boolean}
   */
  contains: function (array, item) {
    return array.indexOf(item) !== -1
  },
  /**
   * insert an item into array at index position
   * @param {Array<*>} array
   * @param {number} index
   * @param {*} item
   * @test.case ['john', 'alice', 'bob'], 0, 'mary' > &['mary', 'john', 'alice', 'bob']
   * @test.case ['john', 'alice', 'bob'], 1, 'mary' > &['john', 'mary', 'alice', 'bob']
   * @test.case ['john', 'alice', 'bob'], -1, 'mary' > &['john', 'alice', 'bob', 'mary']
   * @test.case ['john', 'alice', 'bob'], -2, 'mary' > &['john', 'alice', 'mary', 'bob']
   */
  insert: function (array, index, item) {
    if (index > array.length) {
      index = array.length
    }

    if (array[index]) {
      array.splice(index, 0, item)
    } else {
      array[index] = item
    }
  },

  /**
   * concat arrays
   * @param {...Array<*>} arrays to chain
   * @return {Array<*>} chained arrays
   * @test.case [0,1,2],[3,4,5] > [0,1,2,3,4,5]
   * @test.case [0, 1, 2, 3], ['a', 'b', 'c'], [{a: 2}] > [0, 1, 2, 3, 'a', 'b', 'c', {a: 2}]
   */
  concat: function (args) {
    return Array.prototype.concat.apply(Array.prototype, arguments)
  },
  /**
   * empty array - need to keep references
   * @test.case [0,1,2] > &[]
   * @test.case [] > &[]
   */
  empty: function (array) {
    while (array[0]) {
      array.pop()
    }
  },
  /**
   * push item into array, optionally check if already exists
   */
  add: function (array, item, unique) {
    if (unique && array.contains(array, item)) {
      return
    }
    array.push(item)
  }

}

module.exports = array

},{}],3:[function(require,module,exports){
//const crypto = require('crypto')

/**
 * @namespace tools.hash
 */
const hash = {
  /**
   * Generate hash using sha256 in hex format
   * @method tools.hash.sha256
   * @param {string} data any string
   * @return {string} sha256 in hex format
   *
   * @test
   * 'usk6fgbuygbu6' > 'ee42f619919727584b66fe25248ed4bba8e87dcfb3e62a90143ea17ba48df58e'
   * @test
   * 'lorem ipsum %1283770tv8gv 6c6fgw ucthv iy'
   * > '18d18c26ed98c0e88d9121132be48f42596e899ac50f15f854c9d0a82b9f2cb5'
   */
  sha256: function (data) {
    return crypto.createHash('sha256')
      .update(data)
      .digest('hex')
  }
}

module.exports = hash

},{}],4:[function(require,module,exports){
/**
 * @namespace tools.object
 */
const object = {
  /**
   * merge obj2 into obj1
   * @param {Object} obj1
   * @param {Object} obj2
   * @test.case {a: 1, b: 'ciao'}, {a: 4, c: { d: 8, e: 9}} > &{ a: 4, b: 'ciao', c: { d: 8, e: 9 } }
   */
  merge: function (obj1, obj2) {
    if (!obj1) {
      obj1 = obj2 || {}
      return
    }
    if (!obj2) {
      return obj1
    }

    for (var i in obj2) {
      if (typeof obj2[i] === 'object') {
        if (obj2[i] instanceof Array) {
          obj1[i] = object.clone(obj2[i])
          continue
        }
        if (!obj1[i] || typeof obj1[i] !== 'object') {
          obj1[i] = {}
        }
        object.merge(obj1[i], obj2[i])
      } else {
        obj1[i] = obj2[i]
      }
    }
  },
  /**
   * Clone an array or an object in input
   * @function
   * @param {Object|Array} obj The array or the object to clone
   * @return {Object|Array}
   */
  clone: function (obj) {
    if (obj === null || obj === undefined) {
      return obj
    }
    var _type = (obj instanceof Array) ? 'array' : typeof obj
    if (_type === 'object' || _type === 'array') {
      if (obj instanceof Date) {
        return new Date(obj.getTime())
      } else if (typeof window !== 'undefined') {
        return obj
      } else {
        if (obj.clone) {
          return obj.clone()
        }
          /**
           * @type {Array|Object}
           */
        var _clone = _type === 'array' ? [] : {}
        for (var key in obj) {
          _clone[key] = object.clone(obj[key])
        }
        return _clone
      }
    }
    return obj
  },
  /**
   * @see http://google.github.io/closure-library/api/source/closure/goog/object/object.js.src.html#l225
   * @param {Object} obj
   * @return {Array}
   */
  getKeys: function (obj) {
    if (Object.keys) {
      return Object.keys(obj)
    }
    var _keys = []
    for (var key in obj) {
      _keys.push(key)
    }
    return _keys
  },

  /**
   * @todo check if both are objects
   */
  inherits: function (destination, source) {
      //      util.inherits(destination, source)
    Object.getOwnPropertyNames(source).forEach((property) => {
      destination[property] = source[property]
    })
  },

  /**
   * empty object - need to keep references
   * @test.case {a:0,b:1,c:2,d:[],e:{f:-1}} > &{}
   * @test.case {} > &{}
   */
  empty: function (obj) {
    for (const i in obj) {
      delete obj[i]
    }
  },

  /**
   * flat keys in object
   * @param {object} obj
   * @returns {object}
   * @test.case { a: { a1: 1, a2: 2 }, b: 3 } > { 'a.a1': 1, 'a.a2': 2, 'b': 3 }
   */
  flat: function (obj) {
    const _flat = {}

    const _f = function (obj, base) {
      for (const key in obj) {
        try {
          // eslint-disable-next-line eqeqeq
          if (obj[key].constructor == Object) {
            _f(obj[key], base + key + '.')
          } else {
            _flat[base + key] = obj[key]
          }
        } catch (e) {
          _flat[base + key] = obj[key]
        }
      }
    }
    _f(obj, '')

    return _flat
  },
  /**
   * restore flat object
   * @param {object} obj
   * @returns {object}
   * @test.case { 'a.a1': 1, 'a.a2': 2, 'b': 3 } > { a: { a1: 1, a2: 2 }, b: 3 }
   */
  raise: function (obj) {
    const _raise = {}

    const _f = function (flat, raise) {
      for (const path in flat) {
        const _keys = path.split('.')
        let _cursor = raise
        _keys.forEach((key, i) => {
          if (i < _keys.length - 1) {
            if (!_cursor[key]) {
              _cursor[key] = {}
            }
            _cursor = _cursor[key]
          } else {
            _cursor[key] = flat[path]
          }
        })
      }
    }
    _f(obj, _raise)

    return _raise
  },
  /**
   * get value in object using a flat key
   * @todo check params
   * @param {object} obj
   * @param {string} fkey
   * @returns {object}
   * @test.case { a: { b: {c: 1} } }, 'a.b.c' > 1
   */
  getByFlatKey: function (obj, fkey) {
    let _path = fkey.split('.')
    let _walk = obj
    for (let i = 0; i < _path.length; i++) {
      if (!_walk[_path[i]]) {
        return undefined
      }
      _walk = _walk[_path[i]]
    }
    return _walk
  },

  /**
   * set value in object using a flat key
   * @todo check params
   * @param {object} obj
   * @param {string} fkey
   * @param {*} val
   * @test.case
   * {}, 'a.b.c', 1 > &{ a: { b: {c: 1} } }
   */
  setByFlatKey: function (obj, fkey, val) {
    let _path = fkey.split('.')
    let _walk = obj
    for (let i = 0; i < _path.length; i++) {
      if (!_walk[_path[i]]) {
          // if it's the last step, add key as undefined
        if (i === _path.length - 1) {
          _walk[_path[i]] = undefined
          return
        }
        _walk[_path[i]] = {}
      }
      _walk = _walk[_path[i]]
    }
    _walk = val
  }
}

module.exports = object

},{}],5:[function(require,module,exports){
const hash = require('./hash')

/**
 * @namespace tools.random
 */
const random = {
  /**
   * get random int from 0 to max
   * @method tools.random.rnd
   * @param {number} max
   * @return {number}
   */
  rnd: function (max) {
    if (!max) {
      return 0
    }
    return Math.floor(max * Math.random())
  },
  /**
   * get random int from min to max
   * @method tools.random.number
   * @param {number} min
   * @param {number} max
   * @return {number}
   */
  number: function (min, max) {
    if (!max) {
      return random.rnd(min)
    }
    min = Math.floor(min)
    max = Math.floor(max)
    return min + random.rnd(1 + max - min)
  },
  /**
   * get random string
   * @method tools.random.number
   * @param {number} [length=8]
   * @param {Array} [set=abcdefghijklmnopqrstuvwxyz]
   * @return {string}
   */
  string: function (length = 8, set = 'abcdefghijklmnopqrstuvwxyz') {
    let _str = ''
    for (let i = 0; i < length; i++) {
      _str += random.element(set)
    }
    return _str
  },
  /**
   * get random hex string
   * @method tools.random.hex
   * @param {number} [length=8]
   * @return {string}
   */
  hex: function (length = 8) {
    return random.string(length, '0123456789abcdef')
  },
  /**
   * get random hash string
   * @method tools.random.hash
   * @param {?string} salt
   * @return {string}
   */
  hash: function (salt = '') {
    return hash.sha256(new Date().toISOString() + salt)
  },
  /**
   * get random element from array
   * @method tools.random.hash
   * @param {Array<*>} array
   * @param {Array<*>} not
   * @return {*} element
   */
  element: function (array, not) {
    if (!not) {
      return array[random.number(0, array.length - 1)]
    } else {
      let _item
      let i = 0
      do {
        _item = random.element(array)
      } while (not.indexOf(_item) !== -1 && ++i < array.length)
      return _item
    }
  }
}

module.exports = random

},{"./hash":3}],6:[function(require,module,exports){
/**
 * @namespace tools.string
 */
const string = {
  /**
   * replace placeholders inside graph brackets {} with obj dictionary
   * ~ES6 template string
   * @param {string} str
   * @param {Object} obj
   * @param {boolean=} remove missing placeholders from obj, default false
   * @return {string}
   *
   * @test.case 'hi {name} how are you?', {name: 'Alice'} > 'hi Alice how are you?'
   * @test.case 'hi {name} how are you?', {}, true > 'hi  how are you?'
   * @test.case '{a} one, 2 {b}', {a: 1, b: 'two', c: 3} > '1 one, 2 two'
   * @test.case `multiline {1}\n multiline`, {1: 'one'} > `multiline one\n multiline`
   * @test.case '<div class="{color}">My name is {name} I was born in {year} and my favourite color is {color}</div>{nothing}', {name: 'Alice',year: 2014,color: 'purple'}
   * > '<div class="purple">My name is Alice I was born in 2014 and my favourite color is purple</div>{nothing}'
   */
  template: function (str, obj, remove = false) {
    if (!str) {
      return ''
    }
    return str.replace(/\{([\w.]+)\}/g, function (str, key) {
      return obj[key] ? obj[key] : (remove ? '' : str)
    })
  },

  /**
   * trim string
   * @see http://google.github.io/closure-library/api/namespace_goog_string.html
   * @param {string} str
   * @param {?string[]} cuts
   * @return {string}
   *
   * @test.case ' regular trim      ' > 'regular trim'
   * @test.case ' trim,no,. : \n    ', [',','.',' ', ':', '\n'] > 'trim,no'
   * @test.case ' trim string naneno', ['na','ne','no', ' '] > 'trim string'
   * @test.case '({cut these silly brackets please)}', ['{', '}', '(', ')'] > 'cut these silly brackets please'
   */
  trim: function (str, cuts) {
    if (!cuts) {
      return str.replace(/^[\s\xa0]+|[\s\xa0]+$/g, '')
    } else {
      var _cuts = cuts.join()
      return str.replace(new RegExp('^[' + _cuts + ']+|[' + _cuts + ']+$', 'gm'), '')
    }
  },

  /**
   * @param {string} str
   * @param {string} from
   * @param {string} to
   * @return {string}
   * @test.case 'abcadaeafaga', 'a', '' > 'bcdefg'
   * @test.case '112233445544', '4', '9' > '112233995599'
   * @test.case 'repeat repeat repeat', 'repeat', 'don\'t repeat' > 'don\'t repeat don\'t repeat don\'t repeat'
   * @test.case 'no replace all in js native code that replace all the replace', ' ', '_' >
   * 'no_replace_all_in_js_native_code_that_replace_all_the_replace'
   */
  replaceAll: function (str, from, to) {
    return str.split(from).join(to)
  },

  /**
   * @param {string} str
   * @return {string}
   * @test.case 'alice' > 'Alice'
   * @test.case 'alice smith' > 'Alice smith'
   * @test.case 'alice-smith' > 'Alice-smith'
   */
  capitalize: function (str) {
    return str.substr(0, 1).toUpperCase() + str.substr(1).toLowerCase()
  },

  /**
   * @param {string} prefix
   * @param {string} str
   * @return {string}
   * @test.case 'miss ', 'Alice' > 'miss Alice'
   * @test.case 'miss ', 'miss Alice' > 'miss Alice'
   */
  prependMissing: function (prefix, str) {
    if (str.indexOf(prefix) === 0) {
      return str
    }
    return prefix + str
  },

  /**
   * @param {string} str
   * @param {RegExp} regexp
   * @return {string[]}
   */
  matchAll: function (str, regexp) {
    const _matches = []
    let _match = regexp.exec(str)
    while (_match) {
      _matches.push(_match)
      _match = regexp.exec(str)
    }
    return _matches
  }
}

module.exports = string

},{}],7:[function(require,module,exports){
const time = require('./time')
const array = require('./array')

/**
 * @namespace tools.task
 */

/**
 * simple async parallel task manager
 * @constructor
 * @param {object} options
 * @param {function} options.done callback when all tasks are completed
 */
const Tasks = function (options = {}) {
  const __tasks = []

  return {
    /**
     * add task
     * @param {string} id
     */
    todo: function (id) {
      if (options.chrono) {
        time.chrono.set(id)
      }
      __tasks.push(id)
    },
    /**
     * declare task it's done
     * @param {string} id
     */
    done: function (id) {
      array.remove(__tasks, id)
      if (__tasks.length < 1) {
        if (options.done) {
          options.done()
        }
      }
      if (options.chrono) {
        const _time = time.chrono.get(id)
        time.chrono.clear(id)
        return {chrono: _time}
      }
    }
  }
}

module.exports = Tasks

},{"./array":2,"./time":8}],8:[function(require,module,exports){
const object = require('./object')

/**
 * @namespace tools.time
 */

const time = {
  /**
   * can use across modules using same tag
   */
  chrono: {
    /**
     * @param {?string} [tag=chrono]
     */
    set: function (tag = 'chrono') {
      _chronos[tag] = Date.now()
    },
    /**
     * @param {?string} [tag=chrono]
     */
    reset: function (tag = 'chrono') {
      _chronos[tag] = Date.now()
    },
    /**
     * @param {?string} [tag=chrono]
     */
    clear: function (tag = 'chrono') {
      delete _chronos[tag]
    },
    /**
     * @param {?string} [tag=chrono]
     * @return {number} ms
     */
    get: function (tag = 'chrono') {
      const _now = Date.now()
      return _chronos[tag] ? _now - _chronos[tag] : 0
    }
  },

  /**
   * clear counters
   * if you care about memory leaks
   */
  gc: function () {
    object.empty(_chronos)
  }
}

const _chronos = {}

module.exports = time

},{"./object":4}]},{},[1])

//# sourceMappingURL=atoolbox.min.js.map
